using CsvHelper;
using CsvHelper.Configuration;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace ConsoleApp11
{
    class Program
    {
        static void Main(string[] args)
        {
            // Example
            // 259784,CLR,4.6.2,clrjit.dll,Dev1,Reliability improvements in RYUJIT complier code generation due to a missed AVX encoding case.,Bug,[Servicing Port 4.6.2] : Wrong machine code generated by RyuJIT on AVX2-capable CPU (.NET 4.6.2),Dev1,Resolved,2017.01 D; 2017.05 C
            
            var path = @"C:\Users\rlander\Documents\5c-fixes.csv";

            var rnPath = @"C:\git\dotnet\releases";

            var releases = new Dictionary<string,Release>();
            AddVersion("4.7", "net47");
            AddVersion("4.6.2", "net462");
            AddVersion("4.6.1", "net461");
            AddVersion("4.6", "net46");
            AddVersion("4.5.2", "net452");
            AddVersion("3.5", "net35");

            var improvements = new List<Improvement>();

            using (var reader = new StreamReader(path))
            {
                var csv = new CsvReader(reader);
                csv.Configuration.RegisterClassMap(new ImprovementMap());
                while (csv.Read())
                {
                    var fix = csv.GetRecord<Improvement>();
                    fix.UpdateVersions();
                    improvements.Add(fix);
                    RegisterImprovement(fix);
                }
            }

            UpdateReleaseNotes(releases, rnPath);

            void AddVersion(string version, string tfm)
            {
                releases.Add(version, new Release(version, tfm));
            }

            void RegisterImprovement(Improvement improvement)
            {
                foreach(var version in improvement.Versions)
                {
                    releases[version].AddImprovement(improvement);
                }
            }
        }

        private static void UpdateReleaseNotes(Dictionary<string, Release> releases, string rnPath)
        {
                        
            foreach (var releaseHolder in releases)
            {
                var release = releaseHolder.Value;

                if (release.Improvements.Count == 0)
                {
                    continue;
                }

                var version = release.Version;
                var number = RemoveCharacter(version, '.');
                var file = $"dotnet{number}-changes.md";
                var path = Path.Combine(rnPath, release.TFM, file);
                if (!File.Exists(path))
                {
                    continue;
                }

                var newFile = path + ".new.md";
                
                using (var reader = new StreamReader(path))
                {
                    using (var writer = new StreamWriter(newFile))
                    {
                        var line = string.Empty;
                        var component = string.Empty;
                        var whiteSpaceline = 0;
                        var count = 0;
                        while ((line = reader.ReadLine()) != null)
                        {
                            count++;
                            if (line.StartsWith("## "))
                            {
                                component = line.Substring(3);
                                whiteSpaceline = 0;
                                if (!release.Improvements.ContainsKey(component))
                                {
                                    component = null;
                                }
                                
                            }
                            else if (string.IsNullOrWhiteSpace(line) && whiteSpaceline == 0)
                            {
                                whiteSpaceline++;
                            }
                            else if (string.IsNullOrWhiteSpace(line) && !string.IsNullOrEmpty(component) && whiteSpaceline > 0 )
                            {
                                WriteFixes();
                            }
                            else if (reader.Peek() == -1)
                            {
                                writer.WriteLine(line);
                                WriteFixes();
                                continue;
                            }

                            writer.WriteLine(line);

                            void WriteFixes()
                            {
                                if (release.Improvements.TryGetValue(component, out var componentImprovements))
                                {
                                    foreach (var improvement in componentImprovements)
                                    {
                                        var entry = $"* {improvement.Description} [{improvement.ID}] [Added: May 2017]";
                                        writer.WriteLine(entry);
                                    }
                                    component = null;
                                }

                            }

                        }
                    }
                }
            }

            string RemoveCharacter(string s, char c)
            {
                var buffer = new StringBuilder();

                for (int i = 0; i < s.Length; i++)
                {
                    if (s[i] != c)
                    {
                        buffer.Append(s[i]);
                    }
                }

                return buffer.ToString();
            }
        }
    }

    public class Release
    {
        public Release(string version, string tfm)
        {
            Version = version;
            TFM = tfm;
        }

        public string Version;
        public string TFM;
        public Dictionary<string,List<Improvement>> Improvements = new Dictionary<string, List<Improvement>>();

        public void AddImprovement(Improvement improvement)
        {
            if (Improvements.ContainsKey(improvement.Component))
            {
                Improvements[improvement.Component].Add(improvement);
            }
            else
            {
                var list = new List<Improvement>();
                list.Add(improvement);
                Improvements.Add(improvement.Component, list);
            }
        }
    }

    public class Improvement
    {
        public string ID;
        public string Description;
        public string Component;
        public string VersionString;
        public List<string> Versions = new List<string>();

        public void UpdateVersions()
        {
            var versions = new List<string>();

            var comaSegments = VersionString.Split(',');

            foreach(var comaSeg in comaSegments)
            {
                var slashSegments = comaSeg.Split('/');

                foreach(var slashSeg in slashSegments)
                {
                    var version = slashSeg.Trim();
                    versions.Add(version);
                }
            }

            Versions = versions;
        }

    }

    public sealed class ImprovementMap : CsvClassMap<Improvement>
    {
        public ImprovementMap()
        {
            Map(m => m.ID).Index(0);
            Map(m => m.Component).Index(1);
            Map(m => m.VersionString).Index(2);
            Map(m => m.Description).Index(5);
        }
    }
}